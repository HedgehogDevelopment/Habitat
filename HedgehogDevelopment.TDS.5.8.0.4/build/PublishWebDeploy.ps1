<#

.SYNOPSIS
This powershell script deploys a WDP generated by TDS to a Sitecore Azure instance.
.DESCRIPTION
This powershell script deploys a WDP generated by TDS to a Sitecore Azure instance. The script is designed to work in a default Sitecore installation. 
If your installation is heavilly customized, this script should server as a starting point for your deployment process.

The script will push all Sitecore items and files in the WDP to the Sitecore App Service specified by the publish settings file. After the code is deployed, the Sitecore instance is contacted using
a web service and all post-deployment steps are executed. 

The script will monitor post step execution and optinally display status messages. the script will wait until all post steps are complete or there is a failure in the post step process.

.PARAMETER <PackagePath>
Path to the TDS generated WDP. Leave this blank if the web deploy package was deployed using something other than this script. If blank, the script will only monitor the installation status on the server referenced in the publish settings.

.PARAMETER <PublishSettingsPath>
Path to the publish settings file created by Azure in the App Service management screen. This contains the url and credentials needed to access the MSDeploy server in the App Service

.PARAMETER <UseHttp>
When this switch is specified, the script uses an Http:// connection (not recommended) instead of the default Https://

.PARAMETER <ViewLogs>
When this switch is specified, the script Routes all log messages generated by user PostSteps on the server to the output stream

.PARAMETER <Remove>
When this switch is specified, the script removes the post deploy processor from the server. This will cause the server to recycle.

.EXAMPLE
.\PublishWebDeploy.ps1 -PackagePath .\MySite.wdp.zip -PublishSettingsPath .\MyServer.PublishSettings -ViewLogs

Installs a package where Direct Database Deploy was not specified as part of the build:

.EXAMPLE
.\PublishWebDeploy.ps1 -PackagePath .\MySite.wdp.zip -PublishSettingsPath .\MyServer.PublishSettings -ViewLogs -Remove

Installs a package and removes the Web Deploy post processor:
#>

[cmdletbinding()]
param(
    [string]$PackagePath,
    [string]$PublishSettingsPath,
    [switch]$UseHttp,
    [switch]$ViewLogs,
	[switch]$Remove
)

#Parses the publish settings file 
function ParsePublishSettings($PublishSettingsPath) {
    #Load the XML file
    [xml]$parsedPublishSettings = Get-Content -Path $PublishSettingsPath

    #Find the MSDeploy publishProfile node
    $webDeployPublishProfile = $parsedPublishSettings.publishData.publishProfile | ? {$_.publishMethod -eq "MSDeploy" }

    if ($null -eq $webDeployPublishProfile)
    {
        Throw "Can't find MSDeploy publish profile in publish settings"
    }

    #extract parameters into a profile object
    @{        
        PublishUrl = $webDeployPublishProfile.publishUrl
        Username = $webDeployPublishProfile.userName
        Password = $webDeployPublishProfile.userPWD
        MSDeploySite = $webDeployPublishProfile.msdeploySite
        DestinationAppUrl = $webDeployPublishProfile.destinationAppUrl
    }
}

#Calls MSDeploy to publish the web deploy package to the Azure instance
function PublishPackage($packagePath, $publishSettings, $publishSettingsPath) {
    Write-Output ("Publishing WebDeploy package to " + $publishSettings.MSDeploySite + " on " + $publishSettings.PublishUrl)

    $MSDeployRegEntry = Get-ItemProperty -Path "Registry::HKLM\SOFTWARE\Microsoft\IIS Extensions\MSDeploy" 
    $MSDeployInstallPath =  (Get-ItemProperty -Path ("Registry::HKLM\SOFTWARE\Microsoft\IIS Extensions\MSDeploy\" + $MSDeployRegEntry.LatestVersion)).InstallPath
    $MSDeployExecuteCommand = $MSDeployInstallPath + "MSDeploy.exe"

    Write-Verbose "Running MSDepoy from $MSDeployExecuteCommand"

    $MSDeployCommandArguments = "-verb:sync", `
        "-source:package='$packagePath'",  `
        "-dest:auto,publishSettings='$publishSettingsPath',IncludeAcls='False'", `
        "-setParam:Name=""IIS Web Application Name"",Value=$($publishSettings.MSDeploySite)", `
        "-enableRule:DoNotDeleteRule", `
        "-disableLink:AppPoolExtension", `
        "-disableLink:ContentExtension", `
        "-disableLink:CertificateExtension"
        
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew();

    $MSDeployCommandArgumentsString = "$MSDeployCommandArguments"
    Write-Verbose "MSDeploy command arguments: $MSDeployCommandArgumentsString"

    $cmd = """$MSDeployExecuteCommand"" $MSDeployCommandArgumentsString"
    cmd /c $cmd

    if ($VerbosePreference -eq "continue")
    {
        cmd /c $cmd
    }
    else {
        cmd /c $cmd | Out-Null
    }

    if ($LASTEXITCODE -ne 0)
    {
        throw  "MSDeploy failed"
    }
    
    $stopwatch.Stop();

    Write-Output "Package publish complete in $($stopwatch.Elapsed)"
}

#Invokes the deployment and waits for completion
function InvokeDeployment($publishSettings, $useHttp, $viewLogs, $remove) {
    Write-Output "Beginning package deployment"

    #Force TLS1.2
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    $baseAPIUrl = "$($publishSettings.DestinationAppUrl)/api/TDS/WebDeploy/"

    #Switch URL to HTTPS 
    if (!$useHttp)
    {
        $baseAPIUrl = $baseAPIUrl.Replace("http://","https://")
    }

    #Create the request urls
    $statusRequest = "$($baseAPIUrl)Status"
    $invokeRequest = "$($baseAPIUrl)Invoke" 
    $removeRequest = "$($baseAPIUrl)Remove" 
    $logRequest = "$($baseAPIUrl)Messages?flush=true"
    $clearLogMessageRequest ="$($baseAPIUrl)ClearLogs"

    #Get the current status
    $retryCount = 20
    $requestComplete = $false;
    while($retryCount -ge 0) 
    {
        try
        {
            $statusResponse = Invoke-RestMethod -Uri $statusRequest -TimeoutSec 60

            $requestComplete = $true
            break
        }
        catch
        {
            Write-Warning "Retrying connection to $statusRequest"
            $retryCount--
        }
    }

    if (!$requestComplete)
    {
        Write-Error "Could not contact server at $statusRequest"

        exit
    }

    #See if a deployment is taking place
    if ($statusResponse.DeploymentStatus -eq "Complete" -or $statusResponse.DeploymentStatus -eq "Idle" -or $statusResponse.DeploymentStatus -eq "Failed") {
        #Call the Invoke method to start the deployment. This may not be needed if the server is restarting, but if no Assemblies or configs change
        #it will be needed 
        $invokeResponse = Invoke-RestMethod -Uri $invokeRequest -TimeoutSec 60

        if ($invokeResponse -ne "Ok")
        {
            throw "Request to start deployment failed"
        }

        Write-Output "Starting Deployment"
    }

    #Wait a bit to allow a deployment to start
    Start-Sleep -Seconds 2

    #Get the current status to see which deploy folder is being deployed
    $statusResponse = Invoke-RestMethod -Uri $statusRequest -TimeoutSec 60
    $currentDeploymentFolder = $statusResponse.CurrentDeploymentFolder
    
    while ($true) {
        #Get the current status
        $statusResponse = Invoke-RestMethod -Uri $statusRequest -TimeoutSec 60
        Write-Verbose "Server Deploy State: $($statusResponse.DeploymentStatus)"

        #If the deployment folder has changed, complete the progress
        if ($statusResponse.CurrentDeploymentFolder -ne $currentDeploymentFolder)
        {
            Write-Progress -Completed -Activity "Deploying Web Deploy Package from $currentDeploymentFolder"
        }

        #Update the progress bar
        Write-Progress -PercentComplete  $statusResponse.ProgressPercent -Activity "Deploying Web Deploy Package from $($statusResponse.CurrentDeploymentFolder)"

        #If the user wants deployment logs, write the logs
        if ($viewLogs) {
            $logResponse = Invoke-RestMethod -Uri $logRequest -TimeoutSec 60

            Write-Output $logResponse
        }

        #Stop if all deployment folders have been deployed
        if ($statusResponse.DeploymentStatus -eq "Complete" -or $statusResponse.DeploymentStatus -eq "Idle" -or $statusResponse.DeploymentStatus -eq "Failed") {
            break
        }

        Start-Sleep -Seconds 5        
    }

	if ($remove) {
		Write-Output "Removing installer service from webserver"

		Invoke-RestMethod -Uri $removeRequest -TimeoutSec 600
	}

    Write-Progress -Completed -Activity "Deploying Web Deploy Package from $($statusResponse.CurrentDeploymentFolder)"
}

if (-not($PublishSettingsPath)) { Throw "Please specify a value for -PublishSettingsPath"}

$publishSettings = ParsePublishSettings $PublishSettingsPath

$currentDirectory = Split-Path $MyInvocation.MyCommand.Path

if ($PackagePath)
{
    $PackagePath = (Get-Item -Path ($currentDirectory + "\" +  $PackagePath)).FullName

    PublishPackage $PackagePath $publishSettings $PublishSettingsPath

    #Wait until server has recognized that files may have changed and begins its restart
    Start-Sleep -s 5
}

InvokeDeployment $publishSettings $UseHttp $ViewLogs $Remove

Write-Output "Package deployment complete"